## 基础类型

### 整型

- 定义：正整数、0、负整数
- Python2.x 用 `int` 存储小整形，用 `long` 存储大整型。Python3.x 只用 `int` 无论大小
- 不同进制的整型表示
    ```
    二进制 0b...，转换函数是 `bin()`
    八进制 0o...，转换函数是 `oct()`
    十六进制 0x...，转换函数是 `hex()`
    ```
- 从 Python3.x 开始支持用 `_` 来分割很长的整型，`a = 1_000_000_000_000_000_000_000`
- 小整型对象：[-5, 257) 内的整型对象，Python 会预先创建好，并放到缓存池中，避免频繁创建对象和内存管理操作（`malloc` 和 `free`
  ）
- 大整型对象：Python 不会预先创建好整形对象，但是会预先换分出一大块内存，避免频繁的内存管理操作

### 浮点型

#### 浮点型的计算的坑

```
In [91]: a = 0.29
In [92]: b = 0.29 * 100
In [93]: c = int(b)
In [94]: c
Out[94]: 28

# 解决方法一：转换成分数计算
In [112]: from fractions import Fraction
In [113]: a = Fraction(29) / Fraction(100)
In [114]: b = a * 100
In [115]: c = int(b)
In [116]: c
Out[116]: 29

# 解决方法二：转换成定点数运算
In [117]: from decimal import Decimal
In [118]: a = Decimal("0.29")
In [119]: b = a * 100
In [120]: c = int(b)
In [121]: c
Out[121]: 29
```

#### decimal 的四舍五入

```
# 情况一：当结果小数点前非 0 时，则保留的个数包括整数位的个数
In [130]: import decimal
     ...:
     ...: decimal.getcontext().prec = 5
     ...:
     ...:
     ...: division = decimal.Decimal(77) / decimal.Decimal(3)
     ...: print(division)
25.667

# 情况二：当小数点前是 0 时，结果保留个数只包括小数位的个数
In [4]: import decimal
In [5]: decimal.getcontext().prec = 5
In [6]: division = decimal.Decimal(1) / decimal.Decimal(3)
In [7]: print(division)
0.33333
```

#### round() 的坑

```
In [46]: round(11.485, 2)
Out[46]: 11.48

# 预期结果是 11.49，原因是当小数的末尾是 5，而 `round()` 刚好使用末尾的 5 进行四舍五入时，
# 将不会进行「五入」。可以使用 decimal 模块修复这种问题
In [1]: import decimal
In [2]: res = round(13.485, 2)
In [3]: correct_res = decimal.Decimal(res).quantize(decimal.Decimal('0.00'), rounding=decimal.ROUND_UP)
In [4]: print(correct_res)
13.49
```

### 字符串类型

- Unicode 种类
    - Latin-1 编码：如果字符串中的所有字符都在 ASCII 范围内，则使用该编码
    - UCS-2 编码：大多数的非拉丁系的字符（比如：汉语、日语等），都会使用该编码
    - UCS-4 编码：如果字符串中含有特殊字符、emoji、稀有字符等，则会使用该编码
- 字符串扩容规则：如果一个 Latin-1 编码的字符串加入了一个中文，那么原先的 Latin-1 字符串所占的字节数将会增加 2 倍。同理，如果加入了一个
  emoji 表情， 所占的字节将会增加 4 倍。所以，如果在一个长字符串中加入了一个 emoji 字符，内存的消耗可能会大大增加
- Python 不使用 UTF-8 的原因：UTF-8
  不是一种定长的编码方式，会根据每个字符的实际所需去分配字节数，这样会造成字符串无法根据索引快速访问相应字符。比如 `string="abcd😄"`
  ，`string[4]` 就不能定位到 😄
- 缓存机制：对于 ASCII 字符串，如果长度没有超过20个，那么这个对象将会被放到缓存池中
- 字符串拼接性能问题：多使用 `join()`，而不是 `+`，前者一次性分配内存，后者多次分配内存
- 编码和解码：抓住编码方和解码方这两头，注意使用的编码方式要一样，不然可能会发生乱码

---

## 容器类型

### list

Python 中的列表应该叫动态数组，类似 C++ 的 vector、Java 的 arraylist、Go 的
slice，动态数组的特性它都有。底层存在动态扩容操作， 但是外部没有提供操作容量的接口，总体来说随机读操作和尾部的增删操作性能都很好

### dict

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/python%E5%AE%B9%E5%99%A8-2.png)

从字典源码的第一行就可以知道，Python 的字典底层是基于哈希表做的，并且是基于开发寻址法解决冲突的哈希表。哈希表的特性它都有，底层存在动态扩容操作，
总的来说读操作的性能非常好，写操作的性能也不错

### set

集合的底层也是哈希表，增删查操作基本上和字典一样，主要关注它特有的集合操作

### 其他

除了内置的容器类型，标准库 collections 还提供了双端队列、二叉堆、有序字典等数据结构

### 参考

- [Built-in Types](https://docs.python.org/3/library/stdtypes.html#built-in-types)
- [Python 源码](https://github.com/python/cpython/blob/master/Objects/dictobject.c)
- [Python 源码解析](https://flaggo.github.io/python3-source-code-analysis/objects/object/)

---

## 变量

### 变量查找顺序

1. 局部变量（函数体内、方法体内、类内）
2. 闭包变量
3. 全局变量
4. import 进来的
5. 内置变量
6. 报错

### 作用域的坑

控制流程语句：`if、for、while` 等不会将全局变量变成局部变量

```
In [174]: x = 1

In [175]: if True:
    ...:     print(x) # 此时的 x 是上面全局变量
    ...:     x = 2    # 这里赋值的 x 也是全局变量
    ...:     print(x)
    ...:
1
2
```

函数、类声明语句：`def、class、lambda` 等可以会将全局变量变成局部变量

```
In [104]: x = 1

In [105]: def foo():
     ...:     print(x)  # 此时的 x 还是全局变量
     ...:     x = 2     # 对全局变量重新赋值，x 从全局变量变成了局部变量，这会导致上一句 print(x) 使用了未定义的变量
     ...:

In [106]: foo()
---------------------------------------------------------------------------
UnboundLocalError                         Traceback (most recent call last)
<ipython-input-106-c19b6d9633cf> in <module>
----> 1 foo()

<ipython-input-105-916a4a5ce689> in foo()
      1 def foo():
----> 2     print(x)
      3     x = 2
      4

UnboundLocalError: local variable 'x' referenced before assignment
```

解决方法是当使用全局变量时，用 `global` 显式声明。

```
In [181]: x = 1

In [182]: def foo():
    ...:     global x
    ...:     print(x)
    ...:     x = 2
    ...:     print(x)
    ...:

In [183]: foo()
1
2
```

### 可变对象的坑

- Python 中的不可变对象有：数值（整型、浮点型）、字符串、tuple、frozenset
- 可变对象最为默认参数的坑
    ```
    In [3]: def foo(l=[]):
       ...:     l.append(1)
       ...:     print(l)
       ...:
    
    In [4]: foo()
    [1]
    
    In [5]: foo()
    [1, 1]
    
    In [6]: foo()
    [1, 1, 1]
    
    In [7]: foo()
    [1, 1, 1, 1]
    ```
- 常见面试题
  ```
  问：写出下面代码的输出
  
  def foo(k, v, dic={}):
      dic[k] = v
      print(dic)
  
  
  foo(1, 1)
  foo(2, 2)
  foo(3, 3, {})
  foo(4, 4)   # 进阶考法
  ```

### copy vs. deepcopy

```
# 问题: copy deepcopy 对 id 的影响 (基本类型/容器类型)
# 答: copy(基本类型) 对 id 没影响; deepcopy(基本类型) 对 id 没影响。
#     copy(单层容器) 对 id 有影响; copy(双层容器) 对整个对象的 id 有影响, 但是对内层的元素没影响;
#     deepcopy(单层容器) 对 id 有影响; deepcopy(多层容器) 对 id 有影响。

import copy

arg = [[1, 2, 3, 4, 5]]
print(id(arg[0]))


def foo(arg):
    arg = copy.deepcopy(arg)
    print(id(arg[0]))


foo(arg)
```

---

## 控制流程

### 推导式

- 列表推导式：`l = [i for i in range(10) if i % 2 == 0]`
- 字典推导式：`d = {i:i for i in range(10) if i % 2 == 0}`
- 集合推导式：`s = {i for i in range(10) if i % 2 == 0}`
- 元祖推导式：`t = tuple((i for i in range(10) if i % 2 == 0))`

```
# 推导式除了可以让代码风格更加 Pythonic 之外，对性能也有比较大的好处。
# 各运行 10 次，取平均值，前者耗时 3000ms 左右，后者耗时 650ms 左右，相差 4.5 倍左右

# code1
if __name__ == "__main__":
    l = list()

    for i in range(9999999):
        l.append(i)

# code2
l = [i for i in range(9999999)]        
```

### `zip()` 同时遍历多个容器

```
In [99]: for x in zip([1, 2, 3], [4, 5, 6]):
    ...:     print(x[0], x[1])
    ...:
1 4
2 5
3 6
```

---

## 函数

### 参数传递

常见面试题：

```
# 问题1: 函数传参时, 传递的是同一个对象吗 (基本类型/容器类型)
# 答: 无论是基本类型还是容器类型, 传递的都是同一个对象

# 问题2: 修改形参, 如何影响实参 (基本类型/容器类型)
# 答: 基本类型不会被改变; 容器类型会被改变

# 问题3: copy deepcopy 对问题 2 的影响
# 答: 对于单层容器, copy 可以实现修改形参不影响实参的效果, 对于多层容器则不行; deepcopy 则都行
```

### 可变参数

- 使用场景：函数的参数个数不确定、装饰器等
- *args：代表若干个值，或者序列的展开（*list、*tuple、*set），在函数体内会被转换成 `tuple`
- **kwargs：代表若干个键值对，或者字典的展开（**dict），在函数体内会被转换成 `dict`

### 装饰器

#### 装饰器的执行顺序

```python
def wrapper_out1(func):
    # 实际开发中一般不在外部写语句，避免装饰器执行顺序太复杂
    print('--out11--')

    def inner1(*args, **kwargs):
        print("--in11--")
        ret = func(*args, **kwargs)
        print("--in12--")
        return ret

    # 实际开发中一般不在外部写语句，避免装饰器执行顺序太复杂
    print("--out12--")
    return inner1


def wrapper_out2(func):
    print('--out21--')

    def inner2(*args, **kwargs):
        print("--in21--")
        ret = func(*args, **kwargs)
        print("--in22--")
        return ret

    print("--out22--")
    return inner2


@wrapper_out2
@wrapper_out1
def test():
    print("--test--")
    return 1 * 2


if __name__ == '__main__':
    test()
```

1. `f = wrapper_out2()(wrapper_out1()(test))`
2. 从右到左执行，即先 `wrapper_out1()`、再 `wrapper_out2()`
    ```
    --out11--
    --out12--
    --out21--
    --out22--
    ```
3. 表达式变成 `f = inner2(inner1(test))`
4. 从左到右执行，即先 `inner2()`、再 `inner1()`、再 `test()`
    ```
    --in21--
    --in11--
    --test--
    --in12--
    --in22--
    ```

```
# 完整的输出结果
--out11--
--out12--
--out21--
--out22--
--in21--
--in11--
--test--
--in12--
--in22--
```

※ 在实际开发中，一般不需要这么复杂，可以规定先执行的装饰器放在上面，然后将额外的逻辑加在 inner 函数的开头处就可以：

```python
def wrapper_out1(func):
    def inner1(*args, **kwargs):
        print("--in11--")
        ret = func(*args, **kwargs)
        return ret

    return inner1


def wrapper_out2(func):
    def inner2(*args, **kwargs):
        print("--in21--")
        ret = func(*args, **kwargs)
        return ret

    return inner2


@wrapper_out2
@wrapper_out1
def test():
    print("--test--")
    return 1 * 2
```

#### 使用案例

```python
from functools import wraps


# 基本用法, 用于函数
def foo(f, *args, **kwargs):
    @wraps(f)
    def _foo(*args, **kwargs):
        print("---> args:", args)
        print("---> kwargs:", kwargs)
        f(*args, **kwargs)

    return _foo


@foo
def bar(age, sex):
    print("---> age:", age)
    print("---> sex:", sex)


bar(23, sex="male")


# 基本用法, 用于类
def singleton(cls, *args, **kw):
    instance={}
    def _singleton():
        if cls not in instance:
            instance[cls] = cls(*args, **kw)
            
        return instance[cls]

    return _singleton


@singleton
class test_singleton:
    def __init__(self):
        self.num_sum = 0

    def add(self):
        self.num_sum = 100


# 带参装饰器
def foo(name=None):
    def _foo(f, *args, **kwargs):
        @wraps(f)
        def __foo(*args, **kwargs):
            print("---> name:", name)
            print("---> args:", args)
            print("---> kwargs:", kwargs)
            f(*args, **kwargs)

        return __foo

    return _foo


@foo(name="tiger")
def bar(age, sex):
    print("---> age:", age)
    print("---> sex:", sex)


bar(23, sex="male")
```

```python
# 解耦业务逻辑代码
import functools


def auth(f):
    @functools.wraps(f)
    def inner(*args, **kwargs):
        print('auth done.')
        return f(*args, **kwargs)

    return inner


def login(f):
    @functools.wraps(f)
    def inner(*args, **kwargs):
        print('login done.')
        return f(*args, **kwargs)

    return inner


@login
@auth
def test(name):
    print('I am {}'.format(name))


if __name__ == '__main__':
    test('tiger')
```

```python
# 本地缓存
import functools


def cache(f):
    @functools.wraps(f)
    def inner(*args, **kwargs):
        inner.total += 1
        print('total: {}'.format(inner.total))
        return f(*args, **kwargs)

    inner.total = 0
    return inner


@cache
def test(name):
    print('I am {}'.format(name))


if __name__ == '__main__':
    test('tiger')
    test('tiger')
    test('tiger')
```

> `@functools.wraps(f)` 是为了防止被装饰函数的 `__doc__`, `__name__` 被错误修改

### 函数式编程

- lambda 表达式：`lambda x: x+1`，`lambda _: None`
- [map(func, iterator)](https://docs.python.org/3/library/functions.html#map)
- [filter(func, iterator)](https://docs.python.org/3/library/functions.html#filter)
- [functools.reduce(func, iterator)](https://docs.python.org/3/library/functools.html#functools.reduce)
- `sorted(student_tuples, key=lambda student: student[2], reverse=False)`

### 生成器

- 生成器的定义：含有 `yield` 语句的函数、方法就是生成器

#### 使用场景（常用）

```python
# 节省内存：在不使用生成器的情况下，需要实打实地创建一个列表，可能会消耗了不少内存
def foo(max):
    l = []
    for i in range(max):
        i += 1
        l.append(i)
    return l


if __name__ == "__main__":
    # 假设 max 是一个非常大的数量，比如 sys.maxsize
    max = 99999
    res = foo(max)
    for i in res:
        print(i)
```

```python
# 使用生成器优化后不需要一次性地创建一个列表，只需要在每次 `yield` 的时候申请单个元素的内存，省了不少内存
def gen(max):
    for i in range(max):
        i += 1
        yield i


if __name__ == "__main__":
    # 假设 max 是一个非常大的数量，比如 sys.maxsize
    max = 99999
    g = gen(max)
    for i in g:
        print(i)
```

#### 生成器的操作

- yield：`yield` 表达式可以中断生成器。
- `__next__()` | next()：`__next__()` 方法 或者 next()
  函数可以唤醒中断的迭代器。当生成器已经执行完了，会抛出 `StopIterator` 异常。
- send()：`send()` 方法可以唤醒中断的迭代器，并且发送一个值到生成器内部，赋值到 `yield` 语句前面的变量。
  ```
  In [220]: def foo(n):
       ...:     for i in range(n):
       ...:         j = yield i
       ...:         if j == -1:
       ...:             break
       ...:
       ...:
       ...: if __name__ == "__main__":
       ...:     g = foo(5)
       ...:     print(g.__next__())
       ...:     print(g.__next__())
       ...:     g.send(-1)          # 给 j 赋值 -1, 生成器内的循环终止
       ...:     print(g.__next__()) # 再次调用 __next__() 抛出 StopIteration 异常
       ...:
  0
  1
  ---------------------------------------------------------------------------
  StopIteration                             Traceback (most recent call last)
  <ipython-input-220-af4a7bdcff3b> in <module>
       10     print(g.__next__())
       11     print(g.__next__())
  ---> 12     g.send(-1)
       13     print(g.__next__())
  
  StopIteration:
  ```
- throw()：`throw()` 方法可以唤醒中断的迭代器，并且发送一个异常到生成器内部。
  ```
  In [225]: def foo(n):
       ...:     try:
       ...:         for i in range(n):
       ...:             j = yield i
       ...:             if j == -1:
       ...:                 break
       ...:     except ValueError:
       ...:         yield "ValueError"
       ...:
       ...:
       ...: if __name__ == "__main__":
       ...:     g = foo(5)
       ...:     print(g.__next__())
       ...:     print(g.__next__())
       ...:     print(g.throw(ValueError))
       ...:
  0
  1
  ValueError
  ```
- close()：`close()` 方法用于主动关闭生成器。

---

## 异常处理

- 异常定义：异常是指潜在的，发生时间不确定的一些列错误，比如磁盘空间不足、网络中断、运行时错误等
- 异常处理作用：异常会导致程序中断退出，异常处理机制相当于给了一个机会，让程序在发生异常后能够重新夺回程序的控制权

### 标准异常

- AttributeError：访问的属性不存在
- IOError：I/O 异常
- ImportError：无法引入模块或包，多是路径问题、名称错误、安装问题
- IndexError：下标错误
- KeyError：访问的 key 不存在
- KeyboardInterrupt：Ctrl+C 信号引发
- NameError：使用未定义的变量
- SyntaxError：语法错误
- TypeError：类型不匹配
- UnboundLocalError：访问未赋值的局部变量
- ValueError：传入的值不符合要求
- OSError：系统错误
- RuntimeError: 运行时错误
- 完整异常类型：https://docs.python.org/3/tutorial/errors.html#errors-and-exceptions

### 异常处理原则

- 多考虑异常处理，特别当程序有各种依赖时，比如对本地系统的资源依赖（磁盘）、对网络环境的依赖、第三方系统组件的依赖等
- 优先级越高的异常处理放越上面，优先处理
- 粒度越细、越具体的异常，越要放上面，避免永远都无法捕获到

### 获取异常信息

```python
import traceback

try:
    1 / 0
except:
    print("---> 捕获到的异常信息: {}".format(traceback.format_exc()))
```

---

## 包和模块

### 使用规范

- Python2.x 的包必须有 `__init__.py` 文件，Python3.x 非必须
- 多用 `from ... import ...` 而不是 `import m1.m2.m3`
- `from ... import ...` 时建议到模块级别，而不是模块里面的东西
- 如果 Python 文件需要单独以脚本形式运行，务必加上 `if __name__ == "__main__"`，它可以确保 Python
  文件在单独运行时 `__name__` 是 `__main__`， 以模块形式导入时，`__name__` 是模块本身的名字
- 多用 `__all__` 控制模块暴露的属性

### ImportError

- 如果 Python 代码是以脚本形式运行的
  ```
  import sys
  import os
  sys.path.append(os.path.dirname(os.path.abspath(__file__)))
  ```
- 如果 Python 代码是以模块形式运行的，在 `site-packages` 目录下新建一个以 `.pth`
  结尾的文件，将项目的顶级目录写进去，一劳永逸

---

## OOP

### 封装

- Python 用 `__` 标记私有属性，封装是 "假的"，只是用 `_${class_name}__${field_name}`
  给私有属性改了个名字，实际上还是能够访问得到
  ```
  In [163]: class A:
       ...:     def __init__(self):
       ...:         self.__name = "A"
       ...:
       ...:     def __get_name(self):
       ...:         return self.__name
       ...:
       ...:
       ...: if __name__ == "__main__":
       ...:     a = A()
       ...:     print(a._A__name)
       ...:     print(a._A__get_name())
       ...:
  A
  A
  ```

> 单下划线 `_` 用来标识模块的私有成员

### 继承

- Python 支持多继承，常用的 Mixin 模式就是基于多继承的特性，子类可以继承不同的 Mixin 类，动态组合需要的功能
  ```
  In [165]: class DictMixin:
       ...:     def __getitem__(self, key):
       ...:         return self.__dict__[key]
       ...:
       ...:     def __setitem__(self, key, value):
       ...:         self.__dict__[key] = value
       ...:
       ...:
       ...: class RunnertMixin:
       ...:     def run(self):
       ...:         print("---> I can run")
       ...:
       ...:
       ...: class People(DictMixin, RunnertMixin):
       ...:     def __init__(self, name, age, sex):
       ...:         self.name = name
       ...:         self.age = age
       ...:         self.sex = sex
       ...:
       ...:
       ...: if __name__ == "__main__":
       ...:     p = People("yoko", 23, "female")
       ...:     print(p["name"], p["age"], p["sex"])
       ...:     p.run()
       ...:
  yoko 23 female
  ---> I can run
  ```
- 多用 Mixin 写 Python 味的代码

### 多态

- Python 可以做出多态的效果，但是由于 Python 是动态语言，本身没有静态类型限制和严格的类型检查，不存在向上转型、向下转型这些概念，
  理论上它的变量可以接受任意类型的对象，是个 "假的" 多态

### 类和对象

#### `__init__()` 和 `__new__()`

- `__init__()` 用来初始化对象
- `__new__()` 用来创建对象，线程安全，可以用来实现线程安全的单例模式

#### @property

- `@property` 用来写类似 Java 的 getter/setter 方法。
  ```
  In [167]: class People:
       ...:     def __init__(self, name, age, sex):
       ...:         self.__name = name
       ...:         self.__age = age
       ...:         self.__sex = sex
       ...:
       ...:     @property
       ...:     def name(self):
       ...:         return self.__name
       ...:
       ...:     @property
       ...:     def age(self):
       ...:         return self.__age
       ...:
       ...:     @property
       ...:     def sex(self):
       ...:         return self.__sex
       ...:
       ...:     @name.setter
       ...:     def name(self, name):
       ...:         self.__name = name
       ...:
       ...:     @age.setter
       ...:     def age(self, age):
       ...:         if age < 0 or age > 250:
       ...:             return
       ...:         self.__age = age
       ...:
       ...:     @sex.setter
       ...:     def sex(self, sex):
       ...:         if sex not in ("male", "female", "transsexual"):
       ...:             return
       ...:         self.__sex = sex
       ...:
       ...:
       ...: if __name__ == "__main__":
       ...:     p = People("yoko", 23, "female")
       ...:     print(p.name, p.age, p.sex)
       ...:
       ...:     p.name = "yoko1"
       ...:     p.age = 24
       ...:     p.sex = "male"
       ...:     print(p.name, p.age, p.sex)
       ...:
  yoko 23 female
  yoko1 24 male
  ```

#### super()

- `super()` 一般用于调用基类的方法
  ```
  class A:
    def __init__(self, name):
      self.name = name
  
  class B(A):
    def __init__(self, name, age):
      super().__init__(name)
      self.age = age
  ```
- 多继承时，`super().xxx` 对应的是第一个基类

#### 修改类属性的坑

- 对类属性的修改必须通过类本身进行，如果通过对象修改，Python 运行时只会给对象新增一个属性
  ```
  In [173]: class A:
       ...:     flag = 1
       ...:
       ...:
       ...: class B(A):
       ...:     pass
       ...:
       ...:
       ...: if __name__ == "__main__":
       ...:     a = A()
       ...:     b = B()
       ...:     print("---> 修改前 A.flag:", A.flag)
       ...:     print("---> 修改前 B.flag:", B.flag)
       ...:     print("---> 修改前 a.flag:", a.flag)
       ...:     print("---> 修改前 b.flag:", b.flag)
       ...:
       ...:     a.flag = 2
       ...:     print("---> 修改后 A.flag:", A.flag)
       ...:     print("---> 修改后 B.flag:", B.flag)
       ...:     print("---> 修改后 a.flag:", a.flag)
       ...:     print("---> 修改后 b.flag:", b.flag)
       ...:
  ---> 修改前 A.flag: 1
  ---> 修改前 B.flag: 1
  ---> 修改前 a.flag: 1
  ---> 修改前 b.flag: 1
  
  ---> 修改后 A.flag: 1
  ---> 修改后 B.flag: 1
  ---> 修改后 a.flag: 2
  ---> 修改后 b.flag: 1
  ```

#### 类方法使用对象属性的坑

- 对象可以使用类属性，但是反过来类不能使用对象的属性
  ```
  In [181]: class A:
       ...:     flag = 1
       ...:
       ...:     def __init__(self):
       ...:         self.name = "xxx"
       ...:
       ...:     @classmethod
       ...:     def show(cls):
       ...:         print(cls.flag)
       ...:         print(name)
       ...:
       ...:
       ...: a = A()
       ...: a.show()
       ...:
  1
  ---------------------------------------------------------------------------
  NameError                                 Traceback (most recent call last)
  <ipython-input-55-97d3136b2c17> in <module>
  ----> 1 a.show()
  
  <ipython-input-53-9ed5474f3e3a> in show(cls)
        6     def show(cls):
        7         print(cls.flag)
  ----> 8         print(name)
        9
  
  NameError: name 'name' is not defined
  ```

### 魔术方法

- Python 提倡的是「鸭子类型」，魔术方法（属性）正是这种思想的体现，通过为类添加魔术方法，让类可以表现出其他类型的特征。

#### 属性相关的魔术方法

- `getatr()` --> `__getattr__()`
- `setattr()` --> `__setattr__()` --> `self.__dict__[k] = v`
- `delattr()` --> `__delattr__()` --> `del self.__dict__[k]`

#### 其他常见魔术方法

```
- 创建、初始化相关的：`__new__()`，`__init__()`
- 内存回收相关的：`__del__()`（如果两个对象循环引用，并且其中一个自定义了该方法，会导致内存泄漏）
- 用来节省内存相关的：`__slots__()`
- 可调用对象：`__call__()`
- 字符串相关的: https://docs.python.org/3/reference/datamodel.html#object.__repr__
- 容器相关的: https://docs.python.org/3/reference/datamodel.html#emulating-container-types
- 上下文管理器: https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers
- 子类检测相关的：https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks
- 比较运算符相关的：https://docs.python.org/3/reference/datamodel.html#object.__lt__
- 数值运算符相关的：https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types
```

### 新式类 vs. 老式类

- 写法上的不同，新式类理论上需要继承 `object`，Python3.x 之后默认就是新式类
- 对象所包含的属性不同，新式类通过继承 `object`，会额外多了一些属性
- 新式类是广度优先，老式类是深度优先
  ```
  class A():
    def __init__(self):
        pass
    def save(self):
        print("This is from A")

  
  class B(A):
      def __init__(self):
          pass
  
  
  class C(A):
      def __init__(self):
          pass
      def save(self):
          print("This is from C")
  
  
  class D(B,C):
      def __init__(self):
          pass
  
  
  fun =  D()
  fun.save()
  
  经典类的答案： This is from A
  新式类的答案： This is from C
  ```
